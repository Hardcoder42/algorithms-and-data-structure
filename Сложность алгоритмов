Массив  ARR.                 Набор SET
R = 1.                       R = 1
S = N.                       S = N
I = N + 1.                   I = 2N + 1
D = 1 + (N - 1) = N.         D = N

Lin - N обычный поиск O(N)
Bin - в 2р эффективнее, но работает только с sorted O(logN)
___
O(1) - Константная сложность. Выполняется независимо от размера входных данных за постоянное время
1. Получение по индексу. (Обращение к элементу напрямую)

my_list = [1, 2, 3, 4, 5] 
element = my_list[2]  # Получить элемент по индексу 2 (значение 3) - O(1)

2. Добавление/удаление элементов с конца списка, перебора элементов не требуется.

my_list = [1, 2, 3, 4, 5] 
my_list.append(6)  # Добавить элемент в конец списка - O(1)
my_list.pop()  # Удалить элемент из конца списка - O(1)

3. Хеширование. Например, в Python есть словари (dict), которые используют хеш-таблицы для быстрого доступа к значениям по ключу:

my_dict = {'a': 1, 'b': 2, 'c': 3} 
value = my_dict['b']  # Получить значение по ключу 'b' - O(1)

5. Получение длины контейнера: списка, строки и тд. Выполняется за постоянное время, так как длина хранится как атрибут и не требует пересчёта:

my_list = [1, 2, 3, 4, 5] 
length = len(my_list)  # Получить длину списка - O(1)

Данные алгоритмы эффективны и быстры независимо от размера входных данных.
______
O(n) - линейная сложность. Выполняется во времени, пропорциональном размеру входных данных. При увеличении размера входных вдвое, время выполнения также увеличивается вдвое.
1. Линейный поиск. Алгоритм поиска в неупорядоченном массиве/списке

def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1

2. Итерация по всем элементам списка(вывод или преобразование)
3. Суммирование элементов массива. Придётся также пройти каждый элемент

def sum_of_elements(arr):
    total = 0
    for element in arr:
        total += element
    return total

4. Копирование. Тоже может пригодиться каждый элемент.
5. Подсчёт количества вхождения элемента в массив. Придётся пройти каждый элемент.

def count_occurrences(arr, target):
    count = 0
    for element in arr:
        if element == target:
            count += 1
    return count

Такие алгоритмы просты и понятны, но на малых объемах. На больших уступают в скорости логарифмическими и константными сложностью.
_____
O(log n) - Логарифмическая сложность. Быстрее, чем линейные алгоритмы. Скорость ограничивается логарифмически по отношению к размеру входных данных. Хорошо масштабируются
1. бинарный поиск - алгоритм поиск в упорядоченном массиве путем деления массива пополам на каждом шаге.
2. двоичное дерево поиска - обеспечивает быстрый поиск, вставку и удаление элементов. n - количество узлов в дереве 
3. quick sort - в среднем имеет временную сложность 0(n log n) разделяет массив на подмассивы, сортирует, а потом объединяет весь массив. В среднем время на разделение и объединение - 0(log n), а каждый массив сортируется за 0(n)
4. алгоритмы на основе "деления и правления"(быстрое возведение в степень, нахождение числа Фибоначчи) имеют сложность 0(log n) благодаря разделению задачи на более мелкие подзадачи, уменьшая размер данных на каждом шаге 
5. алгоритмы на основе деревьев(красно-черные деревья, AVL - деревья)

def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
_____
0(n^2) - Квадратичная сложность. Медленные, неэффективные на больших объемах данных 
1. bubble sort(в среднем и худшем случае)
2. quick sort(в худшем случае самый большой/малый элемент)
3. матричное умножение
4. selection sort(в худшем и среднем случае)
5. insertion sort(в худшем случае)
________

O(n log n) - Линейно-логарифмическая сложность. Такие алгоритмы быстрее, чем линейные, но медленнее, чем логарифмические. Используются для сортировки массивов и других задачах обработки данных.
1. Сортировка слиянием (Merge sort). Вариант сортировки, кт делит массив на 2 части, рекурсивнно сортирует и после объединяет части в sorted array.
2. Быстрая сортировка (Quick sort). Разделяет массив на подмассивы, сортирует, объединяет обратно. В худшем случае сложность может стать квадратичной.
3. Пирамидальная сортировка (Heap sort). Использует бинарное дерево (кучу) для эффективной сортировки.

Данные алгоритмы хороши на больших объемах данных.
